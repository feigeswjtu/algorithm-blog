# 概念
上一篇讲了冒泡排序，这一章我们讲一下比冒泡排序优化一些的选择排序，选择排序又叫选择交换排序，顾名思义，选择排序，就是选择数列中最小的或者最大的值与对应的下标值进行交换。
选择排序比冒泡排序时间上要优秀一点，主要在于，冒泡排序每次比较都需要交换位置，而选择排序通过记录最大或最小位置的索引最后只交换一次位置就可以了。

# 算法描述

比如在一个长度为N的无序数组中，在第一趟遍历N个数据，找出其中最小的数值与第一个元素交换，第二趟遍历剩下的N-1个数据，找出其中最小的数值与第二个元素交换......第N-1趟遍历剩下的2个数据，找出其中最小的数值与第N-1个元素交换，至此选择排序完成。

举例：数组 int[] arr={5,2,8,4,9,1};

-------------------------------------------------------

第一趟排序： 原始数据：5  2  8  4  9  1

最小数据1，把1放在首位，也就是1和5互换位置，

排序结果：1  2  8  4  9  5

-------------------------------------------------------

第二趟排序：

第1以外的数据{2  8  4  9  5}进行比较，2最小，

排序结果：1  2  8  4  9  5

-------------------------------------------------------

第三趟排序：

除1、2以外的数据{8  4  9  5}进行比较，4最小，8和4交换

排序结果：1  2  4  8  9  5

-------------------------------------------------------

第四趟排序：

除第1、2、4以外的其他数据{8  9  5}进行比较，5最小，8和5交换

排序结果：1  2  4  5  9  8

-------------------------------------------------------

第五趟排序：

除第1、2、4、5以外的其他数据{9  8}进行比较，8最小，8和9交换

排序结果：1  2  4  5  8  9

-------------------------------------------------------

# 简单选择排序算法实现

```java
public class SelectionSort implements ISort{
    @Override
    public int[] sort(int[] data) {
        for(int i = 0; i < data.length; i++){
            int k = i;
            for(int j = k + 1; j < data.length; j++){
                if(data[k] > data[j]){
                    k = j;
                }
            }
            if(k != i){
                swap(data, k, i);
            }

        }
        return data;
    }
}
```
# 选择排序算法优化

据上边的分析，如果在每一次查找最小值的时候，也可以找到一个最大值，然后将两者分别放在它们应该出现的位置，这样遍历的次数就比较少了，这种排序算法我们就称其为双重选择排序吧，下边给出代码实现：

```java
public class SelectionDoubleSort implements ISort{
    @Override
    public int[] sort(int[] data) {
        //最左边的元素下标
        int left = 0;
        //最右边的元素下标
        int right = data.length - 1;
        while(left < right){
            int min=left;
            int max=right;
            for(int j = left; j <= right; j++){
                //找出最小值的坐标
                if(data[j] < data[min]){
                    min = j;
                }
                //找出最大值的坐标
                if(data[j] > data[max]){
                    max = j;
                }
            }
            //如果最小值有变化，交换
            if(left != min){
                swap(data, left, min);
            }
            //如果最大值有变化，交换
            if(right != max){
                swap(data, right, max);
            }
            //左边坐标右移一位
            left++;
            //左边坐标左移一位
            right--;
        }
        return data;
    }
}

```

# 性能分析

平均时间复杂度：O(n2)
空间复杂度：O(1)  (用于交换和记录索引)
稳定性：不稳定 （比如序列【5， 5， 3】第一趟就将第一个[5]与[3]交换，导致第一个5挪动到第二个5后面）

